# 简单题


| 难度 | 考点               |
| ---- | ------------------ |
| 3    | 顺序结构的遍历 |

## 题目背景

夜深人静，zsy导员坐在自己的电脑前。书院发的文件摆了一桌子，是不是有QQ的敲门声。感觉又是一个不眠之夜，zsy叹了口气。突然微信跳出一条提示，让他及时上报疫情防控信息汇总，“让我看看哪个[哔--]还没填。”他暗暗骂道。
然后，他发现，自己只能知道哪个人填了和学生名单，但是不知道哪个人没填。他找到了上次没填的你，作为惩罚，你需要帮他找出有谁没有填。
但是车友正在等着你开黑，你并不想耽误时间。不过为了避免承受导员的怒火，你还是拍着胸脯告诉他：“已经没什么好害怕的了。”

## 题目描述

现拥有一个学生名单，每个学生名字对应一个学号（学号按从小到大排），另有一个已填报名单，为已填报学生的学号（按从小到大排）。需要你按学号从小到大的顺序输出未填报学生的名字。

## 输入格式

第一行，两个整数n、m，代表学生个数和已填报学生个数。
接下来n行，每行一个名字和一个学号，用空格隔开。
接下来m行，每行一个学号。

## 输出格式

共（n-m）行，每行一个学号，代表未填报人数。

## 输入样例

```
7 5
Accelerator 45374150
DarkMatter 45374151
RailGun 45374152
MeltDowner 45374153
MentalOut 45374154
Unkown 45374155
SogiitaGunha 45374156
45374150
45374152
45374154
45374155
45374156
```

## 输出样例

```
DarkMatter
MeltDowner
```

## 数据范围与约定

m<=n<500.
名字为一个小于15个字符的字符串。
学号为一个8为数字。

## 示例代码


```c
#include<stdio.h>
int n,m;
int num1[505],num2[505];
char name[505][20];
int main()
{
	int i,j;
	scanf("%d%d",&n,&m);
	for(i=0;i<n;++i)
		scanf("%s %d",name[i],&num1[i]);
	for(i=0;i<m;++i)
		scanf("%d",&num2[i]);
	for(i=0,j=0;i<n;++i,++j)
		while(num1[i]!=num2[j])
			printf("%s\n",name[i++]);
	return 0;
}
```
## 题目分析

这是一个中等的题，遍历一遍就行。唯一的难点就是别写结构体。