# `A`签到之GPA计算

## 题目描述
作为北航的学子，怎么能不会算自己的 GPA 呢？首先带大家回顾一下北航的 GP（绩点） 计算公式：

$$ 
\mathrm{GP}=
\begin{cases}
4-3 \times \frac{(100-x)^2}{1600},	~~&60 \le x \le 100 \\\\
0,		&~~~~x<60
\end{cases}
$$

其中 $x$ 为一个非负整数，代表科目的得分（百分制），计算所得 GP 为该科目的绩点值。

规定计算 GPA 总成绩时采取按学分加权取平均的方式，即：

$$
\mathrm{GPA} = \frac{\sum\_{i=1}^n{{\mathrm{GP}}\_i \times a\_i}}{\sum_{i=1}^n{a\_i}}
$$

其中 $a_i$ 为一个正实数，代表该课程学分。

现在给出艾可雪学姐上学期的科目成绩和学分，请大家帮忙计算一下她的GPA。


## 输入

第一行为一个正整数 $n$（$1 \leq n\le 10$），代表科目数。

下面 $n$ 行，每行两个以空格隔开的数字 $x\_i,a\_i$（$0\le x\_i\le100,\ 0<a\_i\le10$），分别代表第 $i$ 个科目的分数和学分。

## 输出

一行，代表 GPA 总成绩（保留 4 位小数）。


## 输入样例
    6
    98 4
    93 3
    98 1.5
    99 2
    96 3
    50 1
## 输出样例
    3.6958

*AUTHOR：王程远*

# `B`简单的三角形面积

## 题目描述

给定三角形三个顶点的坐标，求三角形的面积。
## 输入
共三行。

每行两个浮点数，分别表示三个顶点的横纵坐标。

## 输出
一行，即该三角形的面积（保留四位小数）
## 输入样例1
    0.0 0.0
    1.0 0.0
    0.0 1.0
## 输出样例1
    0.5000
## 输入样例2
    -1 0
    1 0
    0 2
## 输出样例2
    2.0000
## Hint

### 提示1

如果已知三角形三条边的边长，可以用海伦公式求出三角形的面积。设三角形三条边的边长为$a$, $b$, $c$，则三角形的面积为$S=\sqrt{p\left( p-a \right) \left( p-b \right) \left( p-c \right)}$，其中$p=\frac{a+b+c}{2}$为三角形周长的一半。

两点距离公式：若已知两点坐标为$\left( x\_1,y\_1 \right) , \left( x\_2,y\_2 \right) $，则两点的距离$d=\sqrt{\left( x\_2-x\_1 \right) ^2+\left( y\_2-y\_1 \right) ^2}$，由此可以计算三角形的三条边边长。

### 提示2

上学期线代学过，两向量的叉乘的模长等于这两个向量所夹的平行四边形的面积，除以2即可得到三角形面积。如果三个顶点分别为$A$,$B$,$C$，只需计算$\left| \vec{AB} \times \vec{AC} \right|$即可。向量的叉乘还记得怎么做吗？

### 提示3

或者直接算下面这个行列式:

$$
S=\frac{1}{2}\cdot \left| \begin{matrix}
	x\_1&		y\_1&		1\\\\
	x\_2&		y\_2&		1\\\\
	x\_3&		y\_3&		1\\\\
\end{matrix} \right|
$$

*AUTHOR: 董翰元*

# `C`SIR 模型算感染人数

## 题目描述

SIR 模型是一种传染病模型。这个模型将人群分为三类：

* 易感染者（Susceptible）：未得病但容易被已感染者感染的人。记第 $n$ 天时的人数为 $S(n)$；
* 已感染者（Infective）：已经患上传染病的人。记第 $n$ 天时的人数为 $I(n)$；
* 移除者（Removed）：病愈免疫后和因病死亡的人。记第 $n$ 天时的人数为 $R(n)$。

在该系统中，总人数 $N = S(n) + I(n) + R(n)$ 保持不变。

此外，系统中还有两个常量参数：感染率 $\beta$ 与移除率 $\gamma$。通过对上述变量构建微分方程模型，可以计算得到不同时刻的各类人群数量，但实际计算过程较为复杂。方便起见，我们可以采用下面的公式进行迭代估算：

$$			
\begin{cases}
S(n+1) - S(n) &= -\beta \frac{S(n)I(n)}{N}	\\\\
I(n+1) - I(n) &= \beta \frac{ S(n) I(n)}{N}-\gamma I(n)	\\\\
R(n+1) - R(n) &= \gamma I(n)	\\\\
\end{cases}
$$

对于给定的 $S(0),\ I(0),\ R(0)$ 与常量参数 $\beta,\ \gamma$，请你计算第 $n$ 天时的已感染者人数 $I(n)$。


## 输入

输入共两行。

第一行四个空格分隔的非负整数 $S(0),\ I(0),\ R(0)$ 与 $n$（$1 \leq n \leq 200$），含义如题。保证 $S(0),\ I(0),\ R(0)$ 与总人数 $N = S(0) + I(0) + R(0)$ 在 `int` 范围内。

第二行两个空格分隔的浮点数 $\beta,\ \gamma$（$0 \leq \beta \leq 10,0 \leq \gamma \leq 1$），且小数点后最多只有两位。



## 输出

输出一行一个整数，表示第 $n$ 天时的已感染者人数 $I(n)$，并四舍五入至整数。

## 输入样例

    27879310  1  78  30
    1.33 0.75

## 输出样例

    818752

## HINT

签到题，循环即可。


## 补充知识

SIR 系统中的两个常量参数基于下述假设：

* 每个已感染者每天有效接触的易感染者的人数是常数 $\beta$，且当易感染者被有效接触后会立即变成已感染者，则称 $\beta$ 为感染率。

* 已感染者每天被移除的人数比例（包括病愈后免疫和死亡）是常数 $\gamma$，则称 $\gamma$ 为移除率。

根据上述假设，SIR 模型可以列写为以下的非线性常微分方程组：

$$
\begin{cases}
\frac{dS}{dt} = -\frac{\beta S I}{N}\\\\
\frac{dI}{dt} = \frac{\beta S I}{N}- \gamma I\\\\
\frac{dR}{dt} = \gamma I\\\\
\end{cases}
$$

解上述微分方程组，即可得到不同时刻的各类人群数量图像，可以参考[百度百科 - SIR模型](https://baike.baidu.com/item/SIR%E6%A8%A1%E5%9E%8B)。

*AUTHOR: 胡湘鹏*

# `D`求阿克曼函数

## 古老的传说

在1928年，阿克曼同学在学习递归函数的时候提出了一个函数，这个函数能够让初学者迅速学会递归。

## 题目描述

阿克曼函数可以使用递归的形式如下表述（$m,n$ 为大于 $0$ 的正整数）

$$ ack(0, n) = n + 1  $$
$$ ack(m, 0) = ack(m − 1, 1)  $$
$$ ack(m, n) = ack(m − 1, ack(m, n − 1))  $$

## 输入格式

一行两个整数 $m,n$，用空格分开。

## 输出格式

一行一个整数。

## 输入样例

    3 10

## 输出样例

    8189

## 数据范围

$ 1\leq m \leq 3,\ 1\leq n \leq 11$

*AUTHOR:杜晨鸿*

# `E`小明又去春游

##  题目描述  
又是一年春天！小明想要出去春游，但由于疫情影响，他只能去当地的 $m$ 个旅游景点玩耍，并且当地旅游业为响应防控疫情的号召，规定每天游客能去的景点数量刚好就是 $8$ 减去星期数，如星期一游客最多能选择任意 $7$ 个景点去玩耍，星期天只能选择任意 $1$ 个景点。若小明打算春游的时候刚好是星期 $x$，他想要去的景点数量为该天能去的最多的景点数量，请问他能有多少种方案呢？
##  输入  
一行，输入当地的景点数 $m$（$7 \leq m \leq 12$） 和小明出游的星期数 $x$（$1 \leq x \leq 7$）。
##  输出  
一行，输出他可以有多少种方案。
##  输入样例  
    9 6
##  输出样例  
    36
##  样例解释
当地有 $9$ 个景点，小明要在星期六（星期数为 $6$）出游，只能选择 $2$ 个景点，组合数$C(9,2)=36$，因此有 $36$ 种选择方案。
##  数据范围
所有数据均在int范围内，毕竟疫情期间还是少出门的好~

*AUTHOR:袁圆*

# `F`Zeller 求星期

## 题目介绍

Zeller 在用蔡勒（Zeller）公式计算一个日期是星期几时，突然了解到罗马教皇格里高利十三世在 1582 年组织了一批天文学家，根据哥白尼日心说计算出来的数据，对儒略历作了修改，**将 1582 年 10 月 5 日到 14 日之间的 10 天撤销**，继 10 月 4 日之后为 10 月 15 日。

因此他在课上学的公式

$$
w=\left(y+\left[\frac{y}{4}\right]+\left[\frac{c}{4}\right]-2c+\left[\frac{13\times\left(m+1\right)}{5}\right]+d-1\right) \bmod 7
$$

**只适用于 1582 年 10 月 15 日及之后的情形**。于是 Zeller 上网查阅资料得知，若要计算的日期是在 1582 年 10 月 4 日及之前，公式为：

$$
w=\left(y+\left[\frac{y}{4}\right]+\left[\frac{c}{4}\right]-2c+\left[\frac{13\times\left(m+1\right)}{5}\right]+d+2\right) \bmod 7
$$

其中 $[x]$ 代表取 $x$ 的整数部分。上式中的其他参数含义如下：

* $c$：去除年份后两位的部分，即当前所在的世纪数$-1$；
* $y$：年份的后两位；
* $m$：月份。在蔡勒公式中，**某年的 1、2 月要看作上一年的 13、14 月**来计算，比如 2003 年 1 月 1 日要看作 2002 年的 13 月 1 日来计算；
* $d$：日期。

最终，$w$ 即是所求日期的星期数。**若计算出的 $w$ 小于 $0$，则 $w$ 加 $7$**。比如 $w$ 是 $3$，则为星期三。如果 $w$ 是 0，则为星期日。

现在给定一个理论上合法的日期 `yyyymmdd`，请你计算这天是星期几。

## 输入格式

多组数据输入。

每组数据包含一行，为 `yyyymmdd` 格式的日期。保证该日期是在公元 1 年 1 月 1 日到公元 9999 年 12 月 31 日之间的合法的日期。（**在不考虑 1582 年 10 月 5 日到 14 日之间的 10 天是不存在的情况时是合法的**）

## 输出格式

对于每组数据，输出一行字符串，表示所求日期对应的星期。我们规定用 `Mon`、`Tue`、`Wed`、`Thu`、`Fri`、`Sat`、`Sun` 分别表示星期一、二、三、四、五、六、日。

若该日期是 1582 年 10 月 5 日到 14 日之间不存在的 10 天之一，输出 `Nonexistent date!`。

## 输入样例

    20200403
    20020403
    20010403
    15821004
    15821010
    15821015

## 输出样例

    Fri
    Wed
    Tue
    Thu
    Nonexistent date!
    Fri

## HINT

是不是感觉很熟悉？看看课件上的例 a4-6，把 PPT 中的代码略加修改即可。

## BTW

这个程序还是挺有用的，比如：如果你不知道你出生那天是星期几，可以用这个程序来查询。


*AUTHOR:宋世英*

# `G` 这个勇者确实很菜所以过分慎重

## 题目描述
作为一名萌新勇者，aikx 深知自己菜，所以不把属性练满，不出门打怪。

为了训练力量和敏捷两大基本属性，aikx 开始选择自己的练功方案，每天训练有三种秘籍供选修：

1. 提升一点力量，一点敏捷；
2. 提升两点力量；
3. 提升两点敏捷。

由于过分慎重，aikx 不允许自己总是力敏不均，如果前一天的训练导致自己偏科，第二天一定要补回来。

给定可供训练的天数 $n$，请问 aikx 共有多少种不同训练方案？（当然，最终要满足力敏均衡）

存在某一天的选修策略不同时，称两种训练方案彼此不同。

答案可能很大，请对 $1,000,007$ 取模。
## 输入
多组数据输入，每组数据一个正整数 $n$（$1 \leq n \le 250$）。
## 输出
对于每组数据，输出一行，表示你的答案对 $1,000,007$ 取模的结果。
## 输入样例
    1
    2
    3
## 输出样例
    1
    3
    5
## 样例解释
$n=1$，只能选修1，共1种；

$n=2$，两次选修1，或选修2、3各一次，共3种；

$n=3$，三次选修1，或在连续的两天内选修2、3，剩余一天选修1，共5种。

## HINT
若想得到满分，需要考虑简单的程序性能优化。

关于取模的性质与操作，可以回顾以往的上机赛。

*AUTHOR：王程远*

# `H`甄医生找工作牌

## 题目介绍

方舱医院里，粗心的医生甄粗心在随机问诊了几名患者后发现自己的工作牌遗失了，他确认自己出发时带着工作牌，所以必然是在问诊时不小心掉在了某张病床旁。

他只记得自己首先去的x号床查看患者1的情况，于是他来到x号床寻找工作牌（没找到），然后向患者1询问自己之后的去向，患者1说：“您去**我右手边**第3张床看患者2了”，于是他来到患者1指明的病床做了同样的事（依然没找到工作牌），患者2说：“您去**对面的**、**我左手边**第2张床看患者3了”......甄粗心如是询问了一部分接受问诊的患者，终于找到了工作牌。

现在，请你编写程序计算：为了寻找工作牌，甄粗心医生一共找了几张病床（包含出发时甄医生所在的x号床和找到工作牌时所在的病床），和工作牌所在的病床号。

假设方舱医院中该区域俯视图如下：

![img](https://i.loli.net/2020/03/28/ev6qmuCSQkYVxRa.png)

## 输入格式

多行输入。

第一行输入2个正整数x、n，满足$1 \leq x \leq n$，$1 \leq n \leq 1000$，分别表示**甄医生去的第一张病床的床号**和**每一排有多少张病床**（一共两排，如上图）。

之后数行，每行输入3个整数a、b、c描述医生的去向，以空格分隔。其中:

$a \in \\{-1, 1 \\}$，-1表示他之后去了**对面**那一排病床，1表示在**本排**；

$b \in \\{-1, 1 \\}$，-1表示患者说医生向**他的左手边**离开，1表示患者说医生向**他的右手边**离开；

$1 \leq c \leq n-1$，表示医生紧接着去了相对于当前床位的该方向上的**第c张床**。

最后一行，输入3个以空格分隔的0，表示找到了工作牌。

**说明**：

①输入保证合法，即医生听从患者指示后必然能找到一张存在的床位。

②默认病人们说话时都面向两排病床中间的过道。

③粗心的甄医生有可能重复多次问诊同一人，即有可能多次来到某一张病床前寻找工作牌。

④多次询问同一人时，神智不清的病人可能给出不同的指示。（但甄医生只需要听从指令即可）

## 输出格式

输出甄粗心医生一共找过几张病床（包含出发时甄医生所在的x号床和找到工作牌时所在的病床，若重复来到某一病床则只计数一次），和工作牌所在的病床号，以空格分隔。

## 输入样例


    8 10
    -1 -1 1
    -1 1 3
    1 -1 2
    1 1 5
    0 0 0


## 输出样例


    5 7


## 样例说明

甄医生的行动路线为：①从**8**号床出发 ②来到“对面的左手边第1张床”，即**14**号床 ③来到“对面的右手边第3张床”，即**4**号床③来到“本排的左手边第2张床”，即**2**号床 ④来到“本排的右手边第5张床”，即**7**号床 ⑤找到了工作牌

## HINT

问题看似复杂，其实暗藏规律。

*AUTHOR：曹博文*

# `I`置换的分解

## 题目介绍
Taofu在学习抽象代数时遇到了一题很简单的作业。由于他的作业实在太多，他不想写这么机械的题目了，于是他把任务交给了你，希望你帮他写个程序做这道题。

Taofu的作业题要求将给定的正整数集上的 $n$ 元置换表为不相交的轮换相乘，其中轮换在书写方式上要求把最小的元写在第一位，不同的轮换间按第一位元素的升序排列。将 $i$ 变换为它自身的轮换省略，不用输出。

## 输入格式
两行，第一行一个数 $n$ ，表示这是一个 $n$ 元置换。

第二行 $n$ 个数，第 $i$ 个数 $a\_i$ 表示的是该置换把 $i$ 变为 $a\_i$ 。

## 输出格式
多行，每行一个轮换。轮换的起始元为该轮换中最小的数，轮换之间按起始元从小到大排列。

## 输入样例
    8
    1 5 7 2 4 3 6 8

## 输出样例
    2 5 4
    3 7 6

## 样例解释
置换 $\sigma=\dbinom{1\quad 2\quad 3\quad 4\quad 5\quad 6\quad 7\quad 8}{1\quad 5\quad 7\quad 2\quad 4\quad 3\quad 6\quad 8}$ 可以表示为 $8$ 元轮换 $(1)$、$(2\ 5\ 4)$ 、$(3\ 7\ 6)$ 和 $(8)$ 相乘，两个将自身变换为自身的轮换省略，仅输出 $(2\ 5\ 4)$ 和 $(3\ 7\ 6)$。

具体算法：

1换到1，省略；

2换到5，5换到4，4换到2，得到轮换 $(2\ 5\ 4)$；

3换到7，7换到6，6换到3，得到轮换 $(3\ 7\ 6)$；

4、5、6、7处理过了，跳过；

8换到8，省略。

## 数据范围
$2\leq n \leq 100$ ，保证所给变换不为恒等变换。

## HINT1
现在Taofu来向你介绍一下置换与轮换的概念：

一个 $n$ 元置换 $\sigma=\dbinom{1\quad \quad 2\quad \quad ...\quad n}{\sigma(1)\quad \sigma(2)\quad ... \quad \sigma(n)}$  将 $1,2,...,n$ 变换为 $\sigma(1),\sigma(2),... ,\sigma(n)$ ，其中 $\sigma(1),\sigma(2),... ,\sigma(n)$ 是 $1,2,...,n$ 的一个排列。

比如$\sigma=\dbinom{1\quad 2\quad 3}{2\quad 3\quad 1}$ 将 $1$ 变换为 $2$ ，将 $2$ 变换为 $3$ ，将 $3$ 变换为 $1$ 。

一个 $n$ 元轮换 $(a\_1\ a\_2\ ...\ a\_k)$ 是 $n$ 元置换的一种特殊情况，表示将 $a\_1$ 变换为 $a\_2$ ， $a\_2$ 变换为 $a\_3$ ，......，$a\_{k-1}$ 变换为 $a\_k$ ， $a\_k$ 变换为 $a\_1$ ，而其它元被变换到自身。

比如一个 $5$ 元轮换 $\sigma=(1\ 2\ 4)$  写成置换形式就是 $\sigma=\dbinom{1\quad 2\quad 3\quad 4\quad 5}{2\quad 4\quad 3\quad 1\quad 5}$ ，它将将 $1$ 变换为 $2$ ，$2$ 变换为 $4$ ，将 $4$ 变换为 $1$ ，其它元变换为自身。

变换相乘（即变换的复合）相信各位在线性代数课程里已经学过了。实在不会就想想数分里复合函数的概念。

现有定理：任一 $n$ 元置换可以被唯一表示为若干个不相交的（即互相之间没有重复的元）的轮换的乘积。

（Taofu寄语：学数学很快乐的，建议你们都试一下）

##HINT2
说人话：什么叫一个轮换？顺着转一圈能回到起点就叫轮换。

*AUTHOR:刘裕炜*

# `J`Four Pegs Hanoi

## 题目介绍

已知有A, B, C, D四根柱子（即“塔”），在A柱上依照上小下大的顺序摞着$N$个黄金圆盘。  

圆盘的移动满足如下规则：  

1. 每次只能移动一个圆盘  
2. 任何时候，小圆盘不能在大圆盘的下面  

如果需要把$N$个圆盘全部移到另一个柱子上，至少需要多少步？  

（没有思路的同学请认真看HINT）

## 输入格式

多行输入。每行一个整数$N$，含义见题干。

## 输出格式

多行输出。对应输入各行中的$N$，输出对应的最小步数。

## 输入样例  
    3  
    11  
## 输出样例  
    5  
    65  
## 数据范围

每组输入数据不超过10行，$N$为不大于$100$的正整数。  

保证输出小于$2 \times 10^5$。

## 助你AC的HINT

* **三柱汉诺塔的步数问题 **

设把A上$N$个圆盘，借助B柱都移到C柱上，需要的步数记为$F3(N)$。  我们的做法如下：  

1. 把A柱上的$N-1$个圆盘借助C柱移到B柱上，这需要$F3(N-1)$步  
2. 把A上最后的一个圆盘直接移到C上，这需要1步  
3. 把B上的$N-1$个圆盘借助A柱移到C上，这需要$F3(N-1)$步。

由此，我们可以得到$F3(N)=2 \times F3(N-1)+1$。

* **四柱汉诺塔的步数问题**  

设把A上$N$个圆盘，借助B, C柱都移到D柱上，需要的步数记为$F4(N)$。  我们的做法如下：  

1. 把A上的$x$个圆盘借助B, D移到C柱上，这需要$F4(x)$步  
2. 把A上剩余的$N-x$个圆盘借助B移到D柱上，这就是我们上面说到的三柱汉诺塔问题。这需要$F3(N-x)$步。（由于C上的圆盘小，所以无法借助C柱）
3. 这时候我们有空的A, B柱，摞着$x$个小圆盘的C柱以及摞着$N-x$个大圆盘的D柱。所以我们只需要把C柱上的$x$个圆盘借助A, B柱移到D柱上，即完成任务。这需要$F4(x)$步。  
4. 考虑到题目所求的是最小步数，因此我们需要计算不同$x$对应的步数，取最优解。

由此，我们可以得到$F4(N)=\min\\{ 2 \times F4(x)+F3(N-x) \mid 0 \leq x < N\\}$。  

* **数据范围**

“ 数据范围的亏吃够了没有？”  

*Author: 李莹 罗慧诗* 

# `K`水水の多项式加法

## 题目描述
在现代科研中，我们可以使用格式各样的数学软件，来方便快速地处理许多数学问题，微分，积分，矩阵运算等等都不在话下。

今天我们来模仿数学软件来处理两个多项式之间的加法。

**先给出多项式中の“项”的定义：**

“项”由系数`c`，未知数符号`u`和次数`p`顺次连接组成，即`cup`是一个合法的“项”。其中系数`c`为一个**非零整数**（若`c`为正，则代表其符号的`+`号不能省略），未知数符号`u`只由**一个小写英文字母**组成，次数`p`是个**非负整数**。

**下面给出多项式的定义：**

（1）单独的一个“项”是多项式；

（2）在多项式`f`后直接连接一个多项式`g`仍然是多项式；

（3）**题目给出的每个多项式**都是由有限次运用规则（1）和（2）得到的；

（4）空多项式是多项式，指不包含任何项的多项式。

**最后给出两个具有 *唯一且相同未知数符号`u`* 的多项式`f`和`g`之间的加法运算的定义：**

（1）新建变量`x`，使`x`为0。新建空多项式`h`；

（2）寻找多项式`f`和`g`中所有次数`p`等于`x`的项：

+ 如果存在，则将他们的系数`c`累加成和记为`s`，  **若`s`不为0**，则将多项式`sup`运用多项式定义（2）的规则连接在多项式`h`后；
+ 如果不存在则不进行操作。

 之后将`x`加1；

（3）重复步骤（2），直到`f`和`g`中所有的项都被处理过了一遍，得到的多项式`h`即为多项式`f`和`g`之间的加法运算的结果。
## 输入
两行，代表两个具有 *唯一且相同未知数符号`u`* 的多项式`f`和`g`：

第一行为一行字符串，代表多项式`f`，

第二行为一行字符串，代表多项式`g`，

保证每个多项式的第一项的系数若是个正整数，代表其符号的`+`号**不**会被省略。

保证组成它们的每个“项”的系数`c`是非0整数，且不超过`int`范围，次数`p`为非负整数满足：$0\le$ `p` $\le10,000$.

保证组成每一个多项式的“项”的个数不超过$10,000$个。
## 输出
一行字符串，代表多项式`f`和`g`之间的加法运算的结果。要求结果的第一项的系数若是个正整数，则**不**省略代表其符号的`+`号。
## 输入样例
    +2x2+3x1-6x2+15x0
    -4x0+2x3-7x2
## 输出样例
    +11x0+3x1-11x2+2x3
## HINT

**真水题。**

神必代码：`int x = 1; printf("%+d", x);`

不保证输入数据的最后一个字符为换行符。

*Author: 李日乾*

# `L`原根

## 题目描述

（**请注意：本题的提示部分提供了三个函数接口供你使用，你可以将这些代码复制进你的程序中。**）

对于正整数 $n$，定义欧拉函数 $\varphi(n)$ 为小于或等于 $n$ 的正整数中与 $n$ 互质的数的个数。如 $n = 9$ 时，与其互质的数为 $1, 2, 4, 5, 7, 8$，故 $\varphi(9) = 6$。

对于给定的正整数 $p$，若整数 $a$ 满足：

* $1 \leq a \leq p$
* $a$ 与 $p$ 互质，即 $a$ 与 $p$ 的最大公约数 $\gcd(a, p) = 1$
* 使 $a ^ d \equiv 1 \pmod p$ 成立的最小正整数 $d = \varphi(p)$，其中符号 $x \equiv y \pmod p$ 表示 $x$ 与 $y$ 在模 $p$ 意义下相等

则称 $a$ 是模 $p$ 的原根。

现在给定 $p$，请你求出模 $p$ 的所有原根。

## 输入格式

本题有多组数据。

第一行一个整数 $q$（$1 \leq q \leq 20$），表示数据的组数。

接下来的 $q$ 行，每行一个正整数 $p$（$2 \leq p \leq 500$），含义见上。


## 输出格式

对于每组数据，输出一行。

若其有 $n$ 个原根，则按照递增的顺序依次输出这 $n$ 个原根，用空格分隔；若其没有原根，输出 $-1$。



## 样例输入

	3
	6
	8
	11

## 样例输出

	5
	-1
	2 6 7 8

## 样例解释

第一组数据中 $p = 6$，仅有 $1, 5$ 与其互质，因此 $\varphi(6) = 2$。不难验证：

* $1 ^ 1\equiv 1 \pmod 6$，因此 $1$ 不是模 $6$ 的原根；
* $5 ^ 1\equiv 5 \pmod 6,\ 5 ^ 2 \equiv 1 \pmod 6$，因此 $5$ 是模 $6$ 的原根。

故模 $6$ 的原根只有 $5$。

第二组数据中 $p = 8$，仅有 $1, 3, 5, 7$ 与其互质，因此 $\varphi(8) = 4$。不难验证：

* $1 ^ 1\equiv 1 \pmod 8$，因此 $1$ 不是模 $8$ 的原根；
* $3 ^ 2\equiv 1 \pmod 8$，因此 $3$ 不是模 $8$ 的原根；
* $5 ^ 2\equiv 1 \pmod 8$，因此 $5$ 不是模 $8$ 的原根；
* $7 ^ 2\equiv 1 \pmod 8$，因此 $7$ 不是模 $8$ 的原根。

故模 $8$ 没有原根。

## 提示1

奇怪的函数增加了！这个函数接受一个正整数 $n$，返回 $\varphi(n)$。

	int Phi(int x){
		int i;
		int ret = x;
		for(i = 2; i * i <= x; i++){
			if(x % i == 0){
				ret = ret / i * (i - 1);
				while(x % i == 0) x /= i;
			}
		}
		if(x > 1) ret = ret / x * (x - 1);
		return ret;
	}

## 提示2

奇怪的函数增加了！这个函数接受两个正整数 $a, b$，返回 $\gcd(a,b)$。

	int GCD(int a, int b){
		return b ? GCD(b, a % b) : a;
	}

## 提示3

奇怪的函数增加了！这个函数接受三个正整数 $a, t, p$，返回 $a^t \bmod p$。

	int PowMod(int a, int t, int p){
		int ret = 1;
		while(t){
			if(t & 1) ret = ret * a % p;
			a = a * a % p;
			t >>= 1;
		}
		return ret;
	}

## 提示4

虽然你可能没办法计算出满足 $a ^ d \equiv 1 \pmod p$ 的最小正整数解 $d$，但是似乎只需要验证 $1 \leq d \leq \varphi(p)$ 中，只有 $d = \varphi(p)$ 满足条件即可。


## 提示5

函数 `Phi()` 的时间开销比其他两个函数稍大，因此你需要避免过多地调用这个函数。





*AUTHOR：廖纪童*