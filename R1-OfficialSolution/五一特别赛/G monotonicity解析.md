# monotonicity
Problem ID : 3333


| 难度 | 考点               |
| ---- | ------------------ |
| 3    | 单调性             |


## 示例代码

    #include <stdio.h>
	int n;
	long long int a, s, sum[1000005];   //直接用longlong存比较方便
	int main() {
	    scanf("%d%lld", &n, &s);
	    for (int i = 1; i <= n; i++) {
	        scanf("%lld", &a);
	        sum[i] = sum[i-1] + a;
	    }
	    int p = 0;
	    for (int i = 0; i <= n; i++)
	        if (sum[i] < s) p = i + 1;
	        else break;
	    if (p == n + 1) {              //所有数的和都不够，说明无解
	        printf("-1");
	        return 0;
	    }
	    int q = 0;
	    int ans = p;                   //给ans一个肯定比答案大的数
	    for (int i = p; i <= n; i++) {
	        while(sum[i]-sum[q+1]>=s&&q+1!=i)q++;  
	        if (i - q < ans) ans = i - q;    //找最短的序列
	    }
	    printf("%d", ans);
	    return 0;
	}


## 题目分析
首先是对范围的判断，1e6个数累加和最大是1e15，所以累加过程不会超过longlong，K的范围也不超过longlong。然后题目解法就是题目名“单调性”。
先用一个数组s表示前缀和，即sum[i]=a[1]+a[2]+...+a[i]，由于之后并不会用到a数组，所以可以不存。这样就可以用sum[j]-sum[i]来表示一段连续序列的和，从i+1位到j位。
定义某个位置的“向右最少延伸位置”为：以这个元素为最左侧的元素，想要满足连续和>=s所需要向右累加到的位置。
考虑计算某个位置开始，向右延伸多少位才能刚好满足题意，如果i到j位满足题意，那么i到j+1位一定也满足，所以满足题意的最小的j就是从i开始向右延伸的情况下的最短序列。
考虑从左向右计算每个位置的“向右最少延伸位置”，假设第一位开始，需要向右连续延伸到m位，即刚好有a[1]+a[2]+...+a[m]>=s，但a[1]+...+a[m-1]<s，那么从第二位开始延伸，最右侧一定不会少于第m位，这是由于所有的a[i]>0。这是显然的：如果a[2]+...+a[m-1]>=s，那么再加上a[1]肯定也满足>=s。
也就是说，从左向右开始每个位置的“向右最少延伸位置”具有单调递增性，也即示例代码中的while语句，看似套在for里可能会很慢，但理论上可以证明，在整个for循环的过程中，while语句判断条件的次数不会超过2n。
所以顺次计算以各个位置为起点，需要的“向右最少延伸位置”，其中的最小值就是答案。