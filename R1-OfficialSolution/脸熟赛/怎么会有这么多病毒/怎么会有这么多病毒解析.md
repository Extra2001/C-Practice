# 怎么会有那么多病毒


| 难度 | 考点               |
| ---- | ------------------ |
| 4    | 结构体、高效排序   |


## 题目介绍
公元20202年，世界各地同时爆发了n种病毒。而人类的科研能力有限，在有限的时间内只能研制m种病毒的解药。为此，我们希望对威胁能力最高的m种病毒进行解药研制，以尽可能拯救生命。

每种病毒具有三种基本指标：传染性、病毒症状、病毒能力，三种指标都是正整数。我们认为病毒的威胁指数为三者之和，即威胁性=传染性+病毒症状+病毒能力。

你需要编写程序来快速完成这项工作：即求出前m种(若n>m则输出m种，若n<m那么只输出n种就可以)最具威胁性的病毒的各项基本指标分别是多少。

## 输入格式
第一行两个数，用空格隔开：n和m，如题所述。

接下来n行，每行有三个数a<sub>i</sub>,b<sub>i</sub>,c<sub>i</sub>，表示一种病毒的传染性、病毒症状、病毒能力指数。

## 输出格式
程序的输出应有min(n,m)行。

第i行表示威胁性第i大的病毒的三种基本指标。

## 输入样例
```
3 2
1 1 5
1 2 6
10 1 3
```

## 输出样例
```
10 1 3
1 2 6
```

## 样例解释
一共有三种病毒，可以研制两种解药。

所以选择威胁性最高的"10+1+3"和"1+2+6"两种病毒来研制解药。

## 数据范围
1≤n≤100000,1≤m≤100000。

对任意的i有：1≤a<sub>i</sub>,b<sub>i</sub>,c<sub>i</sub>≤100001。

数据保证任意两种病毒的威胁性不同。

## HINT
测试数据中将存在n>m，n<m，以及n=m=100000各种情况的数据，提交代码前请考虑周全。

虽然重头是排序方法，但仍建议使用结构体(struct)来使思路更清晰，代码更具可读性。

病毒的威胁性各不相同可以保证输出答案的唯一性，但这个条件可能不仅仅是为了保证这一点。

## 示例代码


```c
#include <stdio.h>
struct point{           //使用结构体存储病毒基本指标和威胁指数
	int a, b, c, k;
}virus[100005];
int s[300005];

int main() {
	int n, m;
	for (int i = 1; i <= 300003; i++) s[i] = -1;
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++) {
		scanf("%d%d%d", &virus[i].a, &virus[i].b, &virus[i].c);
		virus[i].k = virus[i].a + virus[i].b + virus[i].c;      //计算威胁指数
		s[virus[i].k] = i;       //如下述题目分析中描述，如此赋值s数组使s[a]=b表示威胁指数为a的病毒是读进来的b号病毒
	}
	int tot = 0;
	for (int i = 300003; i >= 1; i--) if (s[i] != -1) {
		tot++;
		if (tot > m || tot > n) break;      //已经到n或m种了，停止输出
		printf("%d %d %d\n", virus[s[i]].a, virus[s[i]].b, virus[s[i]].c);
	}
	return 0;
}


## 题目分析
这是一个不太简单的题目：
首先使用结构体或者多个数组来存储各种病毒的指标。由于题目没有给病毒编号，所以结构体可能需要多存一个病毒编号1~n，一个威胁指数。然后考虑排序的方式，如果会用sort函数对结构体排序应该是可以通过的。这里说不用sort的方法：
由于确定了病毒的威胁性各不相同，并且已知威胁性都是1~300003之间的正整数。可以定义数组s[a]=b来表示“威胁性为a的病毒是第b个病毒”。对于读入的第i个病毒，设其威胁性为k<sub>i</sub>，则赋值s[k<sub>i</sub>]=i。
将s数组的所有初始值设为-1可以方便认出具有某个威胁指数的病毒是不存在的。在将所有数据都在s数组中标记后，将s数组从300003~1遍历，得到前m个不为-1的s数组所表示的病毒标号。
