```
日期：2021/05/18
题目链接：https://accoding.cn/problem/3005/index
负责人：荆煦添
考察点：循环/数组
```

## 题目分析

本题是简单的数组运用。核心在于计算存量和增量。

### 首先，我们思考：

1. 需不需要定义数组？
2. 定义数组用来放什么？下标是什么含义？
3. 定义数组的话，数组需要多长呢？

### 解释：

1. 本题的实质是找出两个最大值，一个最小值。找出最值的问题本可以不用定义数组，但仔细阅读题目，题目要求：`如果有多个m, k, l满足条件，则取最晚的k, l，取最早的m。`那**问题就来了**，如果你不用数组的话就需要额外定义很多变量来判断上述条件，让代码变得复杂，因此本题使用数组会让程序逻辑看起来清晰。
2. 本题显然可以将两组原始数据$a_i$和$b_i$放进数组，这样数组下标就与天数有关。一旦输出内容涉及到数组下标，**请关注题目要求输出从$0$开始还是从$1$开始**。例如本题，假如你的数组下标从$0$开始，那么输出时就要$+1$。
3. 长度问题，浏览题目，发现$n\leq 1000$。那么定义两个长度为$1005$的`int`类型数组就差不多了（长度要稍稍长一些）。

### 读入数据

此时，我们定义两个数组：
```c
int a[1005], b[1005];
```
然后，我们就可以循环读入数据了。
```c
int n;
scanf("%d", &n);
for (int i = 0; i < n; i++)
    scanf("%d%d", &a[i], &b[i]);
```
**注意：这种读数据的方式数组下标从0开始。**

### 计算拐点

为了计算拐点，我们需要找出增量最大的**一天**。增量即`a[i] - b[i]`。由于我们需要保存哪一天的增量最大，我们需要定义一个循环外部变量`newday`来保存。
```c
int newday = 0;
```
然后，我们去在数据中寻找增量最大的一天。由于题目要求最晚的拐点，我们从前往后找就是最晚的一天。
```c
for (int i = 0; i < n; i++)
    if (a[newday] - b[newday] <= a[i] - b[i]) // 用当前与已保存的那天比较
        newday = i;
```
**记录的所有天数都是从0开始。**

### 计算医疗压力最大的一天

同样的，为了计算存量最多的一天，我们定义一个变量`max`保存最大存量，`maxDay`保存最大存量的天数。但存量不是增量，是一个与历史有关的问题。因此我们还需要一个总和记录的变量`sum`与其进行比较。
```c
int sum = 0, max = 0, maxDay;
for (int i = 0; i < n; i++)
{
    sum += a[i], sum -= b[i];
    if (sum >= max)
        max = sum, maxDay = i;
}
```
### 计算疫情结束日期
最后，我们计算疫情结束日期。定义一个变量`goodDay`保存。由于寻找最早的一天，我们从后向前找。只要找到最后一天有人出院即可。
```c
int goodDay = 0;
for (int i = n - 1; i >= 0; i--)
    if (b[i])
    {
        goodDay = i;
        break;
    }
```

### 整理

我们回头看一下程序，发现前三个循环的条件都是相同的，并且不会向后访问数据，因此完全可以将三个循环合并：

```c
for (int i = 0; i < n; i++)
{
    scanf("%d%d", &a[i], &b[i]);
    if (a[newday] - b[newday] <= a[i] - b[i])
        newday = i;
    sum += a[i], sum -= b[i];
    if (sum >= max)
        max = sum, maxDay = i;
}
```
### 输出

输出时，千万不要忘记，数组下标与天数的关系！

最后的程序如下：
```c
#include <stdio.h>

int main()
{
    int n, a[1005], b[1005];
    scanf("%d", &n);
    int newday = 0, sum = 0, max = 0, maxDay, goodDay = 0;
    for (int i = 0; i < n; i++)
    {
        scanf("%d%d", &a[i], &b[i]);
        if (a[newday] - b[newday] <= a[i] - b[i])
            newday = i;
        sum += a[i], sum -= b[i];
        if (sum >= max)
            max = sum, maxDay = i;
    }
    for (int i = n - 1; i >= 0; i--)
        if (b[i])
        {
            goodDay = i;
            break;
        }
    printf("%d %d %d", newday + 1, maxDay + 1, goodDay + 1);
}
```

### 总结
实际上，上述就是一个问题拆解，寻找恰当的工具解决问题的过程。这个过程熟能生巧，例如循环的合并，如果做过很多题，经验丰富，就能一眼看出什么样的操作可以放在同一个循环。多多练习吧！同学们。